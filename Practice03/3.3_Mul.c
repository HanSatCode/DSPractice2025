#include <stdio.h>
#include <stdlib.h>
#define MAX(x, y) (((x) > (y)) ? (x) : (y))
#define COMPARE(x, y) (((x) < (y)) ? -1 : ((x) == (y)) ? 0 : 1)

int tempCoef, tempExpon; int sizeA = 0; int sizeB = 0; // 전역 변수
int resultAvail = 0; int tempAvail = 0; int mulCnt = 0;

typedef struct {
	float coef; // 계수 (실수)
	int expon; // 차수 (양의 정수)
} polynomial;
polynomial* result; // 전역 변수로 선언 (리턴할 값)
polynomial* temp; // 전역 변수로 선언 (임시 저장소)

void attach(float confficient, int exponent) { /* 새로운 항을 다항식에 추가한다. */
	temp[tempAvail].coef = confficient;
	temp[tempAvail++].expon = exponent;
	resultAvail++;
}

polynomial* padd(polynomial* A, polynomial* B) { /* A(x)와 B(x)를 더하여 새 D(x)를 생성 */
	float coefficient;
	int startA = 0, startB = 0; int finishA = resultAvail - 1, finishB = sizeB - 1;

	temp = (polynomial*)malloc((sizeA + sizeB) * sizeof(polynomial));
	tempAvail = 0; resultAvail = 0;

	while (startA <= finishA && startB <= finishB) {
		switch (COMPARE(A[startA].expon, B[startB].expon)) {
		case -1: /* a의 차수가 b의 차수보다 작은 경우*/
			attach(B[startB].coef, B[startB].expon);
			startB++;
			break;
		case 0: /* 차수가 같은 경우 */
			coefficient = A[startA].coef + B[startB].coef;
			if (coefficient) attach(coefficient, A[startA].expon); // 계수가 0이 아니면
			startA++; startB++;
			break;
		case 1:  /* a의 차수가 b의 차수보다 큰 경우 */
			attach(A[startA].coef, A[startA].expon);
			startA++;
		}
	}
	
	for (; startA <= finishA; startA++) {
		attach(A[startA].coef, A[startA].expon);
	}
	for (; startB <= finishB; startB++) { // B(x)의 남은 항들을 D(x)에 첨가
		attach(B[startB].coef, B[startB].expon);
	}

	return temp;
}

polynomial* single_mul(polynomial* A, polynomial Bi) {
	/* A(x)와 B(x)를 곱하여 새 Ci(x)를 생성. Bi가 기준임 !!! */
	float confficient; int exponent;
	int startA = 0, startB = 0, finishB = sizeB - 1;
	polynomial* singleTemp = (polynomial*)malloc(sizeB * sizeof(polynomial));
	
	printf("[C%d(x)]\tcoef\texpon\n", ++mulCnt);
	for (; startB <= finishB; startB++) {
		singleTemp[startB].coef = A[startB].coef * Bi.coef;
		singleTemp[startB].expon = A[startB].expon + Bi.expon;
		printf("\t%.2f\t%d\n", singleTemp[startB].coef, singleTemp[startB].expon);
	}

	return singleTemp;
}

polynomial* pmul(polynomial* A, polynomial* B) {
	if (result == NULL) result = (polynomial*)malloc((sizeA * sizeB) * sizeof(polynomial));

	for (int i = 0; i < sizeA; i++) {
		polynomial* Ci = single_mul(B, A[i]); // A를 기준으로 곱해야 됨
		result = padd(result, Ci); // 더하기
	}
	return result;
}

int main(void) {
	// 정렬 자체는 지수를 내림차순으로 넣으면 됨 (내림차순 정렬 구현 안해도됨)
	polynomial* A = (polynomial*)malloc(10 * sizeof(polynomial));
	polynomial* B = (polynomial*)malloc(10 * sizeof(polynomial));

	while (1) {
		printf("[%d번째] A(x)의 계수와 차수를 순서대로 입력하세요. (종료는 -1 -1) : ", sizeA + 1); scanf("%d %d", &tempCoef, &tempExpon);
		if (sizeA > 10) realloc(A, (sizeA + 1) * sizeof(polynomial));	// 10개 초과시 메모리 재할당
		A[sizeA].coef = tempCoef; A[sizeA].expon = tempExpon;
		if (tempCoef == -1 && tempExpon == -1) break; // -1 -1 입력시 종료
		sizeA++;
	}

	printf("[A(x)]\tcoef\texpon\n");
	for (int i = 0; i < sizeA; i++) {
		if (A[i].expon == -1) break;
		printf("\t%.2f\t%d\n", A[i].coef, A[i].expon);
	}

	while (1) {
		printf("[%d번째] B(x)의 계수와 차수를 순서대로 입력하세요. (종료는 -1 -1) : ", sizeB + 1); scanf("%d %d", &tempCoef, &tempExpon);
		if (sizeB > 10) realloc(B, (sizeB + 1) * sizeof(polynomial));	// 10개 초과시 메모리 재할당
		B[sizeB].coef = tempCoef; B[sizeB].expon = tempExpon;
		if (tempCoef == -1 && tempExpon == -1) break; // -1 -1 입력시 종료
		sizeB++;
	}

	printf("[B(x)]\tcoef\texpon\n");
	for (int i = 0; i < sizeB; i++) {
		if (B[i].expon == -1) break;
		printf("\t%.2f\t%d\n", B[i].coef, B[i].expon);
	}

	polynomial* D = pmul(A, B);

	printf("[D(x)]\tcoef\texpon\n");
	for (int i = 0; i < resultAvail; i++) {
		printf("\t%.2f\t%d\n", D[i].coef, D[i].expon);
	}
}
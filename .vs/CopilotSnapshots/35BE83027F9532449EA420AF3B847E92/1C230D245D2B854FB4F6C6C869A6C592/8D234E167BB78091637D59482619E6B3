#include <stdio.h>
#include <stdlib.h>
#define MAX(x, y) (((x) > (y)) ? (x) : (y))
#define COMPARE(x, y) (((x) < (y)) ? -1 : ((x) == (y)) ? 0 : 1)

int tempCoef, tempExpon; int sizeA = 0; int sizeB = 0; // 전역 변수
int avail = 0;

typedef struct {
	float coef; // 계수 (실수)
	int expon; // 차수 (양의 정수)
} polynomial;
polynomial* temp; // 전역 변수로 선언

void attach(float confficient, int exponent) { /* 새로운 항을 다항식에 추가한다. */
	temp[avail].coef = confficient;
	temp[avail++].expon = exponent;
}

polynomial* padd(polynomial* A, polynomial* B) { /* A(x)와 B(x)를 더하여 새 D(x)를 생성 */
	float coefficient;
	int startA = 0, startB = 0; int finishA = sizeA - 1, finishB = sizeB - 1;

	// printf(temp == NULL ? "temp is NULL\n" : "temp is not NULL\n");
	if (temp == NULL)
		temp = (polynomial*)malloc((sizeA + sizeB) * sizeof(polynomial));

	while (startA <= finishA && startB <= finishB) {
		switch (COMPARE(A[startA].expon, B[startB].expon)) {
		case -1: /* a의 차수가 b의 차수보다 작은 경우*/
			attach(B[startB].coef, B[startB].expon);
			startB++;
			break;
		case 0: /* 차수가 같은 경우 */
			coefficient = A[startA].coef + B[startB].coef;
			if (coefficient) attach(coefficient, A[startA].expon); // 계수가 0이 아니면
			startA++;
			startB++;
			break;
		case 1:  /* a의 차수가 b의 차수보다 큰 경우*/
			attach(A[startA].coef, A[startA].expon);
			startA++;
		}
	}
	
	for (; startA <= finishA; startA++) // A(x)의 남은 항들을 D(x)에 첨가
		attach(A[startA].coef, A[startA].expon);
	for (; startB <= finishB; startB++) // B(x)의 남은 항들을 D(x)에 첨가
		attach(B[startB].coef, B[startB].expon);

	return temp;
}

polynomial* single_mul(polynomial* A, polynomial Bi) {
	/* A(x)와 B(x)를 곱하여 새 Ci(x)를 생성. Bi가 기준임 !!! */
	float confficient; int exponent; int mulAvail = 0;
	int startA = 0, startB = 0; int finishA = sizeA - 1, finishB = sizeB - 1;
	polynomial* singleTemp = (polynomial*)malloc((sizeB) * sizeof(polynomial)); // 항의 갯수는 많아봤자 A * B
	
	printf("[C%d(x)]\tcoef\texpon\n", ++mulAvail);
	for (; startB <= finishB; startB++) {
		singleTemp[startB].coef = A[startB].coef * Bi.coef;
		singleTemp[startB].expon = A[startB].expon + Bi.expon;
		printf("\t%.2f\t%d\n", singleTemp[startB].coef, singleTemp[startB].expon);
	}

	return singleTemp;
}

polynomial* pmul(polynomial* A, polynomial* B) { /* A(x)를 기준으로 B(x)를 곱함 */
	int startA = 0, startB = 0; int finishA = sizeA - 1, finishB = sizeB - 1;
	for (int i = 0; i < finishA; i++) {
		polynomial* Ci = single_mul(B, A[i]); // A를 기준으로 곱해야 5개가 나옴..
		temp = padd(temp, Ci); // 누적 합
	}
	return temp;
}

int main(void) {
	// 정렬 자체는 지수를 내림차순으로 넣으면 됨 (내림차순 정렬 구현 안해도됨)
	polynomial* A = (polynomial*)malloc(10 * sizeof(polynomial));
	polynomial* B = (polynomial*)malloc(10 * sizeof(polynomial));

	while (1) {
		printf("[%d번째] A(x)의 계수와 차수를 순서대로 입력하세요. (종료는 -1 -1) : ", sizeA + 1);
		scanf("%d %d", &tempCoef, &tempExpon);
		if (sizeA > 10) realloc(A, (sizeA + 1) * sizeof(polynomial)); // 10개 초과시 메모리 재할당
		A[sizeA].coef = tempCoef;
		A[sizeA].expon = tempExpon;
		if (tempCoef == -1 && tempExpon == -1) break; // -1 -1 입력시 종료
		sizeA++;
	}

	while (1) {
		printf("[%d번째] B(x)의 계수와 차수를 순서대로 입력하세요. (종료는 -1 -1) : ", sizeB + 1);
		scanf("%d %d", &tempCoef, &tempExpon);
		if (sizeB > 10) realloc(B, (sizeB + 1) * sizeof(polynomial)); // 10개 초과시 메모리 재할당
		B[sizeB].coef = tempCoef;
		B[sizeB].expon = tempExpon;
		if (tempCoef == -1 && tempExpon == -1) break; // -1 -1 입력시 종료
		sizeB++;
	}

	polynomial* D = pmul(A, B);

	printf("[D(x)]\tcoef\texpon\n");
	for (int i = 0; i < avail; i++) {
		if (D[i].expon == -1) break;
		printf("\t%.2f\t%d\n", D[i].coef, D[i].expon);
	}
}